---
sidebar_position: 1


---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Hello Automerge: A quick tour

<!-- 
<Tabs>
<TabItem value="js" label="JavaScript">

```js
function helloWorld() {
  console.log('Hello, world!');
}
```

</TabItem>
<TabItem value="py" label="Python">

```py
def hello_world():
  print("Hello, world!")
```

</TabItem>
<TabItem value="java" label="Java">

```java
class HelloWorld {
  public static void main(String args[]) {
    System.out.println("Hello, World");
  }
}
```

</TabItem>
</Tabs> -->

Automerge is a suite of tools for building [local-first](https://www.inkandswitch.com/local-first) web applications with real-time synchronization that works on and offline. 

In this tutorial, you'll build a local-first multiplayer todo-list app with TypeScript, React, Vite, and Automerge. You'll discover how to:

- Represent data as Automerge [documents](automerge.org/TODO)
- Store & synchronize a set of documents in an Automerge [repository](automerge.org/TODO) 
- Build a multiplayer realtime web app client with Automerge's [React hooks](automerge.org/TODO)

All the code here can be found at the [automerge-repo-quickstart](https://github.com/automerge/automerge-repo-quickstart) repo.

## Setup

To get started, clone the tutorial project from [automerge-repo-quickstart](https://github.com/automerge/automerge-repo-quickstart), then enter the `automerge-repo-quickstart` directory and install the project dependencies:

```bash
$ git clone https://github.com/automerge/automerge-repo-quickstart
# Cloning into 'automerge-repo-quickstart'...
$ cd automerge-repo-quickstart
$ yarn
# yarn install v1.22.22
# Resolving packages...

```

Feel free to check out a new branch for your work, and commit your code changes at whatever interval feels comfortable as you work through the tutorial.

```bash 
$ yarn create vite
# Project name: hello-automerge-repo
# Select a framework: React
# Select a variant: TypeScript

$ cd hello-automerge-repo
$ yarn
```

## Modeling Data: Automerge Documents

[Documents](automerge.org/TODO) are the central concept of Automerge. An Automerge document is a JSON-like data structure with superpowers, known as a Conflict-free Replicated Data Type, or [CRDT](automerge.org/TODO).

Each document is identified by a unique [ID](automerge.org/TODO) that looks something like: `automerge:45NuQi1e45PKsemx8GhSCu62gyag`

 Like JSON, Automerge documents support various [data types](automerge.org/TODO), such as a piece of `Text` or an incrementing `Counter`. You'll use the `@automerge/automerge` package to define document(s) that [model the data](automerge.org/TODO) your app needs. 

 ### Define Documents for a todo-list app

...Model some data...



## Storing & Synchronizing: Automerge Repositories

The magic of Automerge Documents is that they support [synchronization](automerge.org/TODO) between all communicating peers working with the same document ID. 

An Automerge Repository, or [Repo](automerge.org/TODO), is what lets you store, synchronize, and manage your app's Documents, and is the second core concept you need to build apps with Automerge.

A Repo keeps track of all the documents you load and makes sure they're properly synchronized and stored. Much like git, this lets you make changes locally, send & receive changes to/from others, and [merge](automerge.org/TODO) those changes as needed. 

The `@automerge/automerge-repo` package lets you create & configure a Repo for documents created with `@automerge/automerge`.


### Initialize a repository

To work with Automerge documents, you first need to configure an Automerge Repo.
Each Repo needs to know:
- Where its documents should be saved, specified via a [StorageAdapter](automerge.org/TODO)
- How/Where to send, retrieve, and synchronize doc updates, specified via a [NetworkAdapter](automerge.org/TODO)

Add the following imports to `src/main.tsx`:

```typescript
import { isValidAutomergeUrl, Repo } from '@automerge/automerge-repo'
import { BroadcastChannelNetworkAdapter } from '@automerge/automerge-repo-network-broadcastchannel'
import { IndexedDBStorageAdapter } from "@automerge/automerge-repo-storage-indexeddb"
import {next as A} from "@automerge/automerge" //why `next`? See the the "next" section of the conceptual overview
```

Then, create a Repo that can synchronize with other tabs using a sort of pseudo-network built into the browser that allows communication between tabs with the same shared origin: the BroadcastChannel.

```js
const repo = new Repo({
  network: [new BroadcastChannelNetworkAdapter()],
  storage: new IndexedDBStorageAdapter(),
})
```

## Creating (or finding) a document

Now that we have the repo, we want to either create a document if we don't have one already or we want to load a document. To keep things simple, we'll check the URL hash for a document ID, and if we don't find one, we'll start a new document and set it in the hash.

Add this code right after the repo initialization code.

```typescript
const rootDocUrl = `${document.location.hash.substr(1)}`
let handle
if (isValidAutomergeUrl(rootDocUrl)) {
    handle = repo.find(rootDocUrl)
} else {
    handle = repo.create<{counter?: A.Counter}>()
    handle.change(d => d.counter = new A.Counter())
}
const docUrl = document.location.hash = handle.url
// @ts-ignore
window.handle = handle // we'll use this later for experimentation
```

A real application would probably handle routing differently, but this is enough to get started.

## Working with the document

The main way of interacting with a Repo is through `DocHandles`, which allow you to read data from a document or make changes to it, and which emit `"change"` events whenever the document changes -- either through local actions or over the network.

Now that we have a document handle stuck onto the window, let's experiment with it. Start your application now with:

`$ yarn dev`

You won't see any changes from the default example application on screen, but we've attached an Automerge document to the `window` object, which makes it conveniently available in the Chrome debugger. 

Your new document is empty, because we just created it. Let's start by initializing a counter. Run the following command in your Chrome debugger.

```typescript
handle.change(d => { d.counter.increment(10) })
```

`DocHandle.change` allows you to modify the document managed by a `DocHandle` and takes care of storing new changes and notifying any peers of new changes.

Next, run this code to see the contents of your document. The contents will look a bit complex, but you should see a counter with a value of 10 if you poke around.

```typescript
handle.docSync()
```

Calling `DocHandle.docSync()` return the current value of the document synchronously, or returns undefined if the document is unavailable either because it is still loading, or because it can't be found. To avoid this problem, prefer the asynchronous form: `await handle.doc()`. If you want to render loading states differently from an unavailable state, you can inspect `handle.state` and branch accordingly.

## Updating your app to use Automerge

We've already created or fetched our initial document via `main.tsx`, but usually when we want to work with a document in a React application, we will refer to it by URL. Let's start by editing the call signature for `App.tsx` to pass in the URL for your newly created document, and then make it available to your component with the `useDocument` hook.

We also need to make the `repo` object we created available throughout the application, so we use a React Context provider for that. In `main.tsx`, modify the `React.render()` call to look like this:

```typescript
ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <RepoContext.Provider value={repo}>
      <App docUrl={docUrl}/>
    </RepoContext.Provider>
  </React.StrictMode>,
)
```

and also add another import line:

```typescript
import { RepoContext } from '@automerge/automerge-repo-react-hooks'
```

Inside `App.tsx`, add these imports:

```typescript
import {AutomergeUrl} from '@automerge/automerge-repo'
import {useDocument} from '@automerge/automerge-repo-react-hooks'
import {next as A} from "@automerge/automerge"
```

and change the first few lines to these:

```typescript
interface CounterDoc {
  counter: A.Counter
}

function App({docUrl}: {docUrl: AutomergeUrl}) {
  const [doc, changeDoc] = useDocument<CounterDoc>(docUrl)
```

Now you've got access to the document in a more native React-style way: a hook that will update every time the document changes.

Our last step here is to change our code to use these new values by replacing how we render the `button` element.

```typescript
        <button onClick={() => changeDoc((d) => d.counter.increment(1))}>
          count is { doc && doc.counter.value }
        </button>
```

Go ahead and try this out. Open a second (or third) tab with the same URL and see how as you click the counter in any tab, the others update.

If you close all the tabs and reopen them, the counter value is preserved.

Congratulations! You have a working Automerge-backed React app with live local synchronization. How does it work? We'll learn through some experimentation in the next section.

## Collaborating over the internet

The handle we have created has a URL, we can access that with `DocHandle.url`, this URL can be used to sync the document with any peer who has it. Open up your browser debugger and run `console.log(handle.url)`, this should print something that looks like `"automerge:45NuQi1e45PKsemx8GhSCu62gyag"`, make a note of this for later.

First, we'll add a network adapter to the `Repo` in our web app which syncs to a sync server via a websocket. Add the following dependency to the web app we've been building:

```bash
yarn add @automerge/automerge-repo-network-websocket
```

Then add a network adapter connecting the repo to `sync.automerge.org`

```
// main.tsx
// Add this import
import { BrowserWebSocketClientAdapter } from "@automerge/automerge-repo-network-websocket"

...

// now update the repo definition to look like this:
const repo = new Repo({
    network: [
        new BroadcastChannelNetworkAdapter(),
        // This is the new line
        new BrowserWebSocketClientAdapter('wss://sync.automerge.org')
    ],
    storage: new IndexedDBStorageAdapter(),
})
```

This creates a repo which syncs changes it sees to `sync.automerge.org`, and any other process can connect to that server and use the URL to get the changes we've made. 

:::note

The Automerge project provides a public sync server for you to experiment with `sync.automerge.org`. This is not a private instance, and as an experimental service has no reliability or data safety guarantees. Basically, it's good for demos and prototyping, but run your own sync server for production uses.

:::

To see this in action we'll create a little node app. Change into a clean directory and run

```bash
npm create @automerge/repo-node-app amg-quickstart
cd amg-quickstart
```

Now open `index.js` and add the following:


```js
// repo is already set up by the `repo-node-app` helper
const doc = repo.find("<url copied from the debugger>")
console.log(await doc.doc())
// This is required because we don't have a way of shutting down the repo
setTimeout(() => process.exit(), 1000)
```

Now run this with `node index.js` and you should see the contents of the document.

Now add the following at the end of `index.js` (but before the setTimeout)

```js
doc.change(d => {
    d.counter.increment(1)
})
```

This change will be reflected in any connected and listening handles. Go back to the original browser window and watch it as you run `node index.js`. What you should see is that every time you run the script the counter in the browser changes.

## Saving the document

If you provide a `Repo` with a `StorageAdapter` then it will save documents for use later. In the browser we might used IndexedDB:

```js
import { IndexedDBStorageAdapter } from "@automerge/automerge-repo-storage-indexeddb"
import { BrowserWebSocketClientAdapter } from "@automerge/automerge-repo-network-websocket"

const repo = new AutomergeRepo.Repo({
  network: [new BrowserWebSocketClientAdapter("wss://sync.automerge.org")],
  storage: new IndexedDBStorageAdapter(),
})
```

Documents will be stored in `IndexedDB` and methods like `Repo.find` will consult storage when loading. The upshot is that if you had a document locally, it will continue to be available regardless of whether you are connected to any peers.


## More

If you're hungry for more, look in the [Cookbook](/docs/cookbook/modeling-data/) section.
