---
sidebar_position: 1


---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Meet Automerge: A Practical Tour

Automerge is a suite of tools for building [local-first](https://www.inkandswitch.com/local-first) web applications with real-time synchronization that works on and offline. 

In this tutorial, you'll build a local-first multiplayer app with TypeScript, React, [Vite](https://vite.dev), and Automerge. You'll discover how to:

- Represent data as Automerge [Documents](/docs/concepts/#documents)
- [Change](/docs/documents/conflicts/) documents' data and [merge](/docs/under-the-hood/merge_rules/) changes from different peers
- Store & synchronize a set of documents in an Automerge [Repository](/docs/concepts/#repositories) 
- Build a multiplayer realtime web app with the Automerge [React client](https://github.com/automerge/automerge-repo/tree/main/packages/automerge-repo-react-hooks)

<figure style={ {margin: '0px auto', textAlign: 'center'} } >
<video src={ require('../static/img/counter-sync-sm.mov').default } width={600} autoPlay loop />
<figcaption>The local-first app in action</figcaption>
</figure>

## Setup

<Admonition type="info">

All the code here can be found at the [automerge-repo-quickstart](https://github.com/automerge/automerge-repo-quickstart) repo.

</Admonition>

To get started:
- clone the tutorial project from [automerge-repo-quickstart](https://github.com/automerge/automerge-repo-quickstart)
- in the `automerge-repo-quickstart` directory, install the project dependencies
- start the local Vite development server 


<Tabs>
<TabItem value="npm" label="npm">

```bash
$ git clone https://github.com/automerge/automerge-repo-quickstart
# Cloning into 'automerge-repo-quickstart'...
$ cd automerge-repo-quickstart
$ npm install
# ...installing dependencies...
$ npm run dev
```

</TabItem>
<TabItem value="yarn" label="yarn">

```bash
$ git clone https://github.com/automerge/automerge-repo-quickstart
# Cloning into 'automerge-repo-quickstart'...
$ cd automerge-repo-quickstart
$ yarn
# ...installing dependencies...
$ yarn dev
```

</TabItem>
</Tabs>


## Model Data as `Document`s

[Documents](/docs/concepts/#documents) are the central concept of Automerge. An Automerge document is a JSON-like data structure with superpowers, aka a Conflict-free Replicated Data Type, or [CRDT](http://crdt.tech).

Each document is identified by a [Document URL](/docs/concepts/#document-urls) that serves as its unique identifier, e.g.:

`automerge:45NuQi1e45PKsemx8GhSCu62gyag`

 Automerge documents support various [data types](/docs/documents/), including builtin JS datatypes like numbers, strings, arrays, and `Date`, as well as Automerge-specific types such as an incrementing `Counter`.

 <Admonition type="info" title="Text in Automerge">

 When working with string values in Automerge apps, keep in mind that [text in Automerge](/docs/documents/text/) is a bit more magical than strings in JS/TS. We'll revisit this point later in the tutorial.

 </Admonition>
 

 
### Defining a Document's Shape

In App.tsx, declare types that define the [data model](/docs/cookbook/modeling-data/) for your app.

For example, for a simple task-tracking app, you might define a single `TaskList` document with a `tasks` array, where each `Task` object in the array has a `title` string and `done` boolean. You can describe this schema with TypeScript interfaces like so:


```ts
// App.tsx

export interface Task {
  title: string;
  done: boolean;
}

// TaskList will be our first Automerge document schema
export interface TaskList {
  tasks: Task[];
}
```


### Changing Documents

Although they look as simple as Plain Old JavaScript Objects (POJOs), Automerge Documents are secretly much more powerful.
 
As changes are made to a Document's data, those changes are stored along with the data itself, and can be "undone", "replayed", and synchronized with other changes made to the same document.

Instead of manipulating a `Document`'s values directly, in Automerge you'll write a callback function with the transformation you want to apply to the given doc. 

Pass the document & the callback function to the `A.change` method, and Automerge will return a new copy of the document with the callback's changes applied.


For example, to check off a task in your list you can update the value of its `.done` property like so:

```ts
// TODO @vakila show the list creation
const list: TaskList = {
  tasks: [
    { title: 'Learn Automerge', done: false },
  ],
};
const done = A.change(list, (d) => { d.tasks[0].done = true; });
```

This type of reassignment in the change handler works well for [simple values](/docs/documents/values/) like a `boolean`, but when working with text - e.g. to change the `.title` of the task - you'll use `A.updateText()` to [more efficiently change string values](/docs/documents/text/) than would be the case with a simple string reassignment.


<Admonition type="info">

Automerge Documents are [immutable](/docs/hello/#design-principles), so each change creates a new document while the original document remains unaltered.

```ts
// TODO @vakila check syntax
const renamed = A.updateText(list.tasks[0], ['title'], 'Learn more Automerge');
console.log(renamed.tasks[0].title) // 'Learn more Automerge'
console.log(renamed.tasks[0].title) // 'Learn Automerge'
```

</Admonition>

### Merging Changes

As the name implies, one of the key powers of Automerge is its ability to [merge](/docs/under-the-hood/merge_rules/) different changes to a given document, much like git lets you merge multiple edits to a given file.

Pass two documents with different changes to `A.merge`, and Automerge will return a new document that includes the changes from both:

```ts
const renamedMore = A.updateText(list.tasks[0], ['title'], 'Learn more Automerge');
const renamedWrite = A.updateText(list.tasks[0], ['title'], 'Write Automerge')

// TODO @vakila syntax
const merged = A.merge([renamedMore, renamedWrite]); 
// TODO @vakila fact check
console.log(merged.tasks[0].title); // 'Write more Automerge'  
```

When merging two different changes to the same property, Automerge uses various strategies to avoid [conflicts](https://automerge.org/docs/documents/conflicts/) and ensure that the merged document will be identical for every user.


## Managing Docs with a `Repo` 

In Automerge apps, you will almost always interact with Documents within an Automerge [Repository](/docs/concepts/#repositories), rather than manipulating them directly with `A.change`. 

An Automerge Repository, or [Repo](/docs/repositories/), keeps track of all the documents you load and makes sure they're properly synchronized and stored. It provides an interface to: 
- create, modify, and manage documents locally
- send & receive changes to/from others, and 
- merge multiple changes as needed.

Repos are the second core concept you need to build apps with Automerge. The `@automerge/automerge-repo` package lets you create & configure a Repo for documents created with `@automerge/automerge`.


Each Repo needs to know:
  - Where its documents should be saved, specified via a [`StorageAdapter`](/docs/repositories/storage/)
  - How/Where to send, retrieve, and synchronize doc updates, specified via zero or more [`NetworkAdapter`](/docs/repositories/networking/)s

You'll specify the `StorageAdapter` and `NetworkAdapter`(s) you need when you initialize a new Repo. Let's try it out.

### Initialize a repository

For this task list app, you'll store documents in an IndexedDB in the browser, and send changes over a Broadcast Channel to keep tabs within the same browser (origin) in sync. 

In `src/main.tsx`, import and instantiate the IndexedDB `StorageAdapter` and BroadcastChannel `NetworkAdapter` from their `@automerge` packages, which have already been included in the project dependencies:

```ts
import { IndexedDBStorageAdapter } from "@automerge/automerge-repo-storage-indexeddb"
import { BroadcastChannelNetworkAdapter } from '@automerge/automerge-repo-network-broadcastchannel'

const broadcast = new BroadcastChannelNetworkAdapter();
const indexedDB = new IndexedDBStorageAdapter();
```

Then, create a new `Repo` by passing in those adapters like so:

```js
const repo = new Repo({
  storage: indexedDB,
  network: [broadcast],
})
```

<Admonition type='info'>

If the Automerge project doesn't have a pre-built adapter that fits your needs, you can create [custom adapter(s)](/docs/repositories/storage/#roll-your-own) as needed.

</Admonition>

### Create or Find a Document

A Repo isn't very useful without any documents in it! To create a document, call `repo.create()` and pass in the initial values of the document:

```ts
const listHandle = repo.create<TaskList>({
  tasks: [
    {
      title: 'Learn Automerge',
      done: false
    }
  ],
});
```

This returns a [`DocHandle`](/docs/repositories/dochandles/) object, which provides an interface for working with the document.

The `DocHandle` has a `.url` property with the document's unique URL:

```ts
listHandle.url // automerge:123abc...
``` 

For this app, we want to either: 
- retrieve the existing document if it exists, or 
- create a new document if we don't have one already. 

It's common practice to pass document IDs around as URL hashes. In this case, you can check the URL hash for a document URL, and if none exists, we'll create a new document and set its ID in the URL hash. (In a production app you'd probably handle routing differently, but this is enough for our example.)


```typescript
const rootDocUrl = `${document.location.hash.substring(1)}`
let handle
if (isValidAutomergeUrl(rootDocUrl)) {
    handle = repo.find(rootDocUrl)
} else {
    handle = repo.create<TaskList>({
      tasks: [
        {
          title: 'Learn Automerge',
          done: false
        }
      ],
    });
}
const docUrl = document.location.hash = handle.url
```

### Read the document


The handle's `doc` method asynchronously loads & returns the document's data from the `Repo`'s storage:

```ts
await listHandle.doc()
```

(There is also a synchronous `.docSync()` method which returns undefined if the document is unavailable either because it is still loading, or because it can't be found.)

<Admonition type="info">

If you want to render loading states differently from an unavailable state, you can inspect `handle.state` and branch accordingly.

</Admonition>


### Manipulate the document


A `DocHandle` also exposes a `.change` method allows you to modify the document. It accepts a callback function for updating the document's data, as we saw before:  

```ts
listHandle.change((d) => { 
  d.tasks.push({ title: 'Create a Repo', done: true })
});
```

The `.change` method takes care of storing new changes, and notifies any peers of new changes by emitting `"change"` events whenever the document changes -- either through local actions or over the network, as determined by the configuration of your Repo's `NetworkAdapter`(s).


## Automerge in React

To make it easier to work with Automerge Repos and Documents in client-side React apps, the `@automerge/automerge-repo-react-hooks` package provides some React-specific conveniences.

### `RepoContext` and `useRepo` hook

A `RepoContext` lets you make your Repo available throughout your React application, via the corresponding `useRepo` hook which can be called in any client component.

In `main.tsx`, modify the `React.render()` call to wrap the `App` component with a  `RepoContext.Provider`, passing in the given `repo` object:

```tsx
import { RepoContext } from '@automerge/automerge-repo-react-hooks'

//...

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <RepoContext.Provider value={repo}>
      <App docUrl={docUrl} />
    </RepoContext.Provider>
  </React.StrictMode>,
)
```


### `useDocument` Hook

Once you have the URL (ID) of the document you want to work with, you can access & modify it from your components with the `useDocument` hook:

```tsx
// App.tsx
import {next as A} from "@automerge/automerge"
import type {AutomergeUrl} from '@automerge/automerge-repo'
import {useDocument} from '@automerge/automerge-repo-react-hooks'

function App({ docUrl }: { docUrl: AutomergeUrl }) {
  const [doc, changeDoc] = useDocument<TaskList>(docUrl);

  // ...
}
```

The `doc` value returned by the hook will initially be `undefined` while the document is loading. Once loaded, `doc` will have the shape of the Document you specified, and will update reactively every time the document changes.

To display the current tasks, you can render `doc.tasks` (just make sure to handle the `undefined` loading case):

```tsx
// App.tsx

function App({ docUrl }: { docUrl: AutomergeUrl }) {
  const [doc, changeDoc] = useDocument<TaskList>(docUrl);

  return (//...
  
    <button>
      { 
        doc && doc.tasks 
          ? `You have ${doc.tasks.length} tasks to do` 
          : 'Loading tasks...' 
      }
    </button>

    //...
  )
}
```  

As you might expect, the `changeDoc` function returned by the `useDoc` hook allows us to change the given document as needed, usually in response to user action. Powered by `A.change` under the hood, `changeDoc` accepts an update callback representing the change to be applied to the existing document.

To check off a task as completed, we can use `changeDoc` in an input's event handler to change the `.done` value, like so:

```tsx 
// TODO @vakila fact check 
    <input type='checkbox' value={doc.tasks[0].done}
      onChange={
        (e) => changeDoc((d) => {
          d.tasks[0].done = e.target.checked;
        })
      } />   
```

## Collaboration in Automerge

### Collaborating Locally

Since the Repo in this app uses a `BroadcastChannelNetworkAdapter`, any changes made to documents in that Repo immediately appear in any other clients with the same origin (i.e. tabs within the same browser).

Go ahead and try this out. Open a second (or third) tab with the same URL and edit the list, observing how other clients' lists are updated accordingly.

If you close all the tabs and reopen them, the document is preserved, as it is stored in your browser's IndexedDB.

Congratulations! You have a working Automerge-backed React app with live local synchronization.

### Collaborating over the internet

In addition to syncing changes locally, changes to your Automerge Repo can be synced with any other user(s) of the same app. 

A document's URL is the unique identifier that allows the Repo to sync the document with any peer who knows that URL. 

Add a network adapter to the `Repo` which syncs to a sync server via a websocket. Add the following dependency to the web app we've been building:


<Tabs>
<TabItem value="npm" label="npm">

```bash
$ npm i @automerge/automerge-repo-network-websocket
```

</TabItem>
<TabItem value="yarn" label="yarn">

```bash
$ yarn add @automerge/automerge-repo-network-websocket
```

</TabItem>
</Tabs>

Then add a network adapter connecting the repo to `sync.automerge.org`

```tsx
// main.tsx

// Add this import:
import { BrowserWebSocketClientAdapter } from "@automerge/automerge-repo-network-websocket";

const repo = new Repo({
    network: [
        new BroadcastChannelNetworkAdapter(),
        // Add this line:
        new BrowserWebSocketClientAdapter('wss://sync.automerge.org')
    ],
    storage: new IndexedDBStorageAdapter(),
})
```

Now, when the Repo sees any changes it will sync them not only locally via the BroadcastChannel, but also over a websocket connection to `sync.automerge.org`, and any other process can connect to that server and use the URL to get the changes we've made. 

:::note

The Automerge project provides a public sync server for you to experiment with, at `sync.automerge.org`. This is not a private instance, and as an experimental service has no reliability or data safety guarantees. Basically, it's good for demos and prototyping, but run your own sync server for production uses.

:::

To see this in action, open the same URL (including the document ID) in a different browser, or on a different device. Unlike the local-only version, you'll now see the data updates synced across _all_ open clients.

###  Network Not Required

Now that the Repo is syncing changes remotely, what happens when the websocket connection is unavailable?

Since the repo stores documents locally with the `IndexedDBStorageAdapter`,  methods like `Repo.find` will consult local storage to retrieve/modify documents, so clients can create new documents while disconnected, and any clients who've already loaded a given document will still be able to make changes to it while offline.

Once connectivity has been re-established, the Repo will sync any local changes with those from remote peers, so everyone ultimately sees the same data. 

## Next Steps

Congratulations! You've built a local-first, offline-capable app that supports multiplayer collaboration locally and over the network.  

If you're hungry for more:
- Look at the [Cookbook](/docs/cookbook/modeling-data/) section for tips on how to model your app's data in Automerge
- Dive deeper into how Automerge [stores](https://automerge.org/docs/under-the-hood/storage/) and [merges](https://automerge.org/docs/under-the-hood/merge_rules/) documents in the 'Under the Hood' section
- Join the [Discord](https://discord.gg/zKGe4DCfgR) to ask questions, show off your Automerge apps, and connect with the Automerge team & community
